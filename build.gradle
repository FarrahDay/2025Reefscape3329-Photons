import edu.wpi.first.toolchain.*

plugins {
    id "java"
    id "cpp"
    id "com.diffplug.spotless" version "6.24.0"
    id "edu.wpi.first.wpilib.repositories.WPILibRepositoriesPlugin" version "2020.2"
    id "edu.wpi.first.GradleRIO" version "2025.2.1"
    id 'edu.wpi.first.WpilibTools' version '1.3.0'
    id 'com.google.protobuf' version '0.9.3' apply false
    id 'edu.wpi.first.GradleJni' version '1.1.0'
    id "org.ysb33r.doxygen" version "1.0.4" apply false
    id 'com.gradleup.shadow' version '8.3.4' apply false
    id "com.github.node-gradle.node" version "7.0.1" apply false
    id "org.hidetake.ssh" version "2.11.2" apply false
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

allprojects {
    repositories {
        mavenCentral()
        mavenLocal()
        maven { url = "https://maven.photonvision.org/releases" }
        maven { url = "https://maven.photonvision.org/snapshots" }
        maven { url = "https://jogamp.org/deployment/maven/" }
    }
    wpilibRepositories.addAllReleaseRepositories(it)
    wpilibRepositories.addAllDevelopmentRepositories(it)
}

ext.localMavenURL = file("$project.buildDir/outputs/maven")
ext.allOutputsFolder = file("$project.buildDir/outputs")

// Configure version number
apply from: "versioningHelper.gradle"

ext {
    wpilibVersion = "2025.3.1"
    wpimathVersion = wpilibVersion
    openCVYear = "2025"
    openCVversion = "4.10.0-3"
    joglVersion = "2.4.0"
    javalinVersion = "5.6.2"
    libcameraDriverVersion = "v2025.0.3"
    rknnVersion = "dev-v2025.0.0-1-g33b6263"
    frcYear = "2025"
    mrcalVersion = "v2025.0.0";


    pubVersion = versionString
    isDev = pubVersion.startsWith("dev")

    // A list with only the current platform contained, for legacy reasons
    wpilibNativeName = wpilibTools.platformMapper.currentPlatform.platformName;
    def nativeName = wpilibNativeName
    if (wpilibNativeName == "linuxx64") nativeName = "linuxx86-64";
    if (wpilibNativeName == "winx64") nativeName = "windowsx86-64";
    if (wpilibNativeName == "macx64") nativeName = "osxx86-64";
    if (wpilibNativeName == "macarm64") nativeName = "osxarm64";
    jniPlatform = nativeName

    println("Building for platform " + jniPlatform + " wpilib: " + wpilibNativeName)
    println("Using Wpilib: " + wpilibVersion)
    println("Using OpenCV: " + openCVversion)


    photonMavenURL = 'https://maven.photonvision.org/' + (isDev ? 'snapshots' : 'releases');
    println("Publishing Photonlib to " + photonMavenURL)
}

spotless {
    java {
        target fileTree('.') {
            include '**/*.java'
            exclude '**/build/**', '**/build-*/**', '**/src/generated/**'
        }
        toggleOffOn()
        googleJavaFormat()
        indentWithTabs(2)
        indentWithSpaces(4)
        removeUnusedImports()
        trimTrailingWhitespace()
        endWithNewline()
    }
    groovyGradle {
        target fileTree('.') {
            include '**/*.gradle'
            exclude '**/build/**', '**/build-*/**'
        }
        greclipse()
        indentWithSpaces(4)
        trimTrailingWhitespace()
        endWithNewline()
    }
    format 'misc', {
        target fileTree('.') {
            include '**/*.md', '**/.gitignore'
            exclude '**/build/**', '**/build-*/**'
        }
        trimTrailingWhitespace()
        indentWithSpaces(2)
        endWithNewline()
    }
}

wrapper {
    gradleVersion '8.11'
}

ext.getCurrentArch = {
    return NativePlatforms.desktop
}

subprojects {
    tasks.withType(JavaCompile) {
        options.compilerArgs.add '-XDstringConcat=inline'
        options.encoding = 'UTF-8'
    }

    // Enables UTF-8 support in Javadoc
    tasks.withType(Javadoc) {
        options.addStringOption("charset", "utf-8")
        options.addStringOption("docencoding", "utf-8")
        options.addStringOption("encoding", "utf-8")
    }
}

// PhotonVision code ends, Robot code begins.

def ROBOT_MAIN_CLASS = "frc.robot.Main"

// Define my targets (RoboRIO) and artifacts (deployable files)
// This is added by GradleRIO's backing project DeployUtils.
deploy {
    targets {
        roborio(getTargetTypeClass('RoboRIO')) {
            // Team number is loaded either from the .wpilib/wpilib_preferences.json
            // or from command line. If not found an exception will be thrown.
            // You can use getTeamOrDefault(team) instead of getTeamNumber if you
            // want to store a team number in this file.
            team = 3329      //project.frc.getTeamNumber()
            debug = project.frc.getDebugOrDefault(false)

            artifacts {
                // First part is artifact name, 2nd is artifact type
                // getTargetTypeClass is a shortcut to get the class type using a string

                frcJava(getArtifactTypeClass('FRCJavaArtifact')) {
                }

                // Static files artifact
                frcStaticFileDeploy(getArtifactTypeClass('FileTreeArtifact')) {
                    files = project.fileTree('src/main/deploy')
                    directory = '/home/lvuser/deploy'
                    deleteOldFiles = true // Change to true to delete files on roboRIO that no
                                           // longer exist in deploy directory of this project
                }
            }
        }
    }
}

def deployArtifact = deploy.targets.roborio.artifacts.frcJava

// Set to true to use debug for JNI.
wpi.java.debugJni = false

// Set this to true to enable desktop support.
def includeDesktopSupport = true

// Defining my dependencies. In this case, WPILib (+ friends), and vendor libraries.
// Also defines JUnit 5.
dependencies {
    annotationProcessor wpi.java.deps.wpilibAnnotations()
    implementation wpi.java.deps.wpilib()
    implementation wpi.java.vendor.java()

    roborioDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.roborio)
    roborioDebug wpi.java.vendor.jniDebug(wpi.platforms.roborio)

    roborioRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.roborio)
    roborioRelease wpi.java.vendor.jniRelease(wpi.platforms.roborio)

    nativeDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.desktop)
    nativeDebug wpi.java.vendor.jniDebug(wpi.platforms.desktop)
    simulationDebug wpi.sim.enableDebug()

    nativeRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.desktop)
    nativeRelease wpi.java.vendor.jniRelease(wpi.platforms.desktop)
    simulationRelease wpi.sim.enableRelease()

    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

test {
    useJUnitPlatform()
    systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
}

// Simulation configuration (e.g. environment variables).
wpi.sim.addGui().defaultEnabled = true
wpi.sim.addDriverstation()

// Setting up my Jar File. In this case, adding all libraries into the main jar ('fat jar')
// in order to make them all available at runtime. Also adding the manifest so WPILib
// knows where to look for our Robot Class.
jar {
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    from sourceSets.main.allSource
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

// Configure jar and deploy tasks
deployArtifact.jarTask = jar
wpi.java.configureExecutableTasks(jar)
wpi.java.configureTestTasks(test)

// Configure string concat to always inline compile
tasks.withType(JavaCompile) {
    options.compilerArgs.add '-XDstringConcat=inline'
}